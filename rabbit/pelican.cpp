//****************************************************************************
// Model: pelican.qm
// File:  ./pelican.cpp
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//****************************************************************************
//${.::pelican.cpp} ..........................................................
#include <QtSerialPort/QtSerialPort>
#include <QMessageBox>

#include "qp_port.h"
#include "bsp.h"
#include "pelican.h"
#include "gui.h"

extern Gui* instance;

Q_DEFINE_THIS_FILE

// Pelican class -------------------------------------------------------------
namespace PELICAN {

//${components::Pelican} .....................................................
class Pelican : public QP::GuiQMActive {
private:
    QP::QTimeEvt m_timeout;
    uint8_t m_flashCtr;

public:
    QSerialPort serial;

public:
    Pelican()
     : GuiQMActive(Q_STATE_CAST(&Pelican::initial)),
       m_timeout(TIMEOUT_SIG)
    {}
    bool port_init();

protected:
    static QP::QState initial(Pelican * const me, QP::QEvt const * const e);
    static QP::QState active  (Pelican * const me, QP::QEvt const * const e);
    static QP::QMState const active_s;
    static QP::QState setup  (Pelican * const me, QP::QEvt const * const e);
    static QP::QMState const setup_s;
    static QP::QState running  (Pelican * const me, QP::QEvt const * const e);
    static QP::QState running_e(Pelican * const me);
    static QP::QState running_x(Pelican * const me);
    static QP::QMState const running_s;
    static QP::QState final  (Pelican * const me, QP::QEvt const * const e);
    static QP::QState final_e(Pelican * const me);
    static QP::QMState const final_s;
};

} // namespace PELICAN

namespace PELICAN {

enum PelicanTimeouts {  // various timeouts in ticks
    CARS_GREEN_MIN_TOUT = BSP_TICKS_PER_SEC * 8, // min green for cars
    CARS_YELLOW_TOUT = BSP_TICKS_PER_SEC * 3,  // yellow for cars
    PEDS_WALK_TOUT   = BSP_TICKS_PER_SEC * 3,  // walking time for peds
    PEDS_FLASH_TOUT  = BSP_TICKS_PER_SEC / 5,  // flashing timeout for peds
    PEDS_FLASH_NUM   = 1,                    // number of flashes for peds
    OFF_FLASH_TOUT   = BSP_TICKS_PER_SEC / 2   // flashing timeout when off
};

// Local objects -------------------------------------------------------------
static Pelican l_Pelican; // the single instance of Pelican active object

// Global objects ------------------------------------------------------------
QP::QActive * const AO_Pelican = &l_Pelican; // the opaque pointer

} // namespace PELICAN

// Pelican class definition --------------------------------------------------
namespace PELICAN {

//${components::Pelican} .....................................................

//${components::Pelican::port_init} ..........................................
bool Pelican::port_init() {
    //qDebug("===========================");
    //me->serial.close();
    serial.setPortName(Gui::instance->portName());
    serial.setBaudRate(Gui::instance->baudrate());
    serial.setDataBits(Gui::instance->data_bits());
    serial.setStopBits(Gui::instance->stop_bits());
    serial.setParity(Gui::instance->parity());

    return !serial.open(QIODevice::ReadWrite);
    //bool res = me->serial.open(QIODevice::ReadWrite);
}
//${components::Pelican::SM} .................................................
QP::QState Pelican::initial(Pelican * const me, QP::QEvt const * const e) {
    static QP::QMTranActTable const tatbl_ = { // transition-action table
        &setup_s,
        {
            Q_ACTION_CAST(0)  // zero terminator
        }
    };
    // ${components::Pelican::SM::initial}
    QS_OBJ_DICTIONARY(&l_Pelican);
    QS_OBJ_DICTIONARY(&l_Pelican.serial);

    QS_FUN_DICTIONARY(&Pelican::initial);
    QS_FUN_DICTIONARY(&Pelican::active);
    QS_FUN_DICTIONARY(&Pelican::final);
    QS_FUN_DICTIONARY(&Pelican::setup);
    QS_FUN_DICTIONARY(&Pelican::running);

    QS_SIG_DICTIONARY(TERMINATE_SIG, &l_Pelican);
    QS_SIG_DICTIONARY(PORT_INIT_SIG, &l_Pelican);
    QS_SIG_DICTIONARY(RUNNING_SIG,   &l_Pelican);
    QS_SIG_DICTIONARY(AUTOSEND_SIG,  &l_Pelican);
    QS_SIG_DICTIONARY(SEND_SIG,      &l_Pelican);
    QS_SIG_DICTIONARY(STOP_SIG,      &l_Pelican);
    QS_SIG_DICTIONARY(STOP_RECEIVE_SIG, &l_Pelican);

    me->subscribe(TERMINATE_SIG);
    me->subscribe(PORT_INIT_SIG);
    me->subscribe(RUNNING_SIG);
    me->subscribe(AUTOSEND_SIG);
    me->subscribe(SEND_SIG);
    me->subscribe(STOP_SIG);
    me->subscribe(STOP_RECEIVE_SIG);
    return QM_TRAN_INIT(&tatbl_);
}
//${components::Pelican::SM::active} .........................................
QP::QMState const Pelican::active_s = {
    static_cast<QP::QMState const *>(0), // superstate (top)
    Q_STATE_CAST(&active),
    Q_ACTION_CAST(0), // no entry action
    Q_ACTION_CAST(0), // no exit action
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${components::Pelican::SM::active}
QP::QState Pelican::active(Pelican * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${components::Pelican::SM::active::TERMINATE}
        case TERMINATE_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[2];
            } const tatbl_ = { // transition-action table
                &final_s,
                {
                    Q_ACTION_CAST(&final_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
//${components::Pelican::SM::active::setup} ..................................
QP::QMState const Pelican::setup_s = {
    &Pelican::active_s, // superstate
    Q_STATE_CAST(&setup),
    Q_ACTION_CAST(0), // no entry action
    Q_ACTION_CAST(0), // no exit action
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${components::Pelican::SM::active::setup}
QP::QState Pelican::setup(Pelican * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${components::Pelican::SM::active::setup::PORT_INIT}
        case PORT_INIT_SIG: {
            bool res = me->port_init();
            // ${components::Pelican::SM::active::setup::PORT_INIT::[res==0]}
            if (res == 0) {
                static QP::QEvt const e(PELICAN::RUNNING_SIG);
                QP::QF::PUBLISH(&e, me);
                status_ = QM_HANDLED();
            }
            // ${components::Pelican::SM::active::setup::PORT_INIT::[else]}
            else {
                status_ = QM_HANDLED();
            }
            break;
        }
        // ${components::Pelican::SM::active::setup::RUNNING}
        case RUNNING_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[2];
            } const tatbl_ = { // transition-action table
                &running_s,
                {
                    Q_ACTION_CAST(&running_e), // entry
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
//${components::Pelican::SM::active::running} ................................
QP::QMState const Pelican::running_s = {
    &Pelican::active_s, // superstate
    Q_STATE_CAST(&running),
    Q_ACTION_CAST(&running_e),
    Q_ACTION_CAST(&running_x),
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${components::Pelican::SM::active::running}
QP::QState Pelican::running_e(Pelican * const me) {
    Gui::instance->setPortState(0);
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&running_s);
}
// ${components::Pelican::SM::active::running}
QP::QState Pelican::running_x(Pelican * const me) {
    Gui::instance->setPortState(1);
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_EXIT(&running_s);
}
// ${components::Pelican::SM::active::running}
QP::QState Pelican::running(Pelican * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // ${components::Pelican::SM::active::running::AUTOSEND}
        case AUTOSEND_SIG: {
            status_ = QM_HANDLED();
            break;
        }
        // ${components::Pelican::SM::active::running::SEND}
        case SEND_SIG: {
            status_ = QM_HANDLED();
            break;
        }
        // ${components::Pelican::SM::active::running::STOP_RECEIVE}
        case STOP_RECEIVE_SIG: {
            status_ = QM_HANDLED();
            break;
        }
        // ${components::Pelican::SM::active::running::PORT_INIT}
        case PORT_INIT_SIG: {
            static struct {
                QP::QMState const *target;
                QP::QActionHandler act[2];
            } const tatbl_ = { // transition-action table
                &setup_s,
                {
                    Q_ACTION_CAST(&running_x), // exit
                    Q_ACTION_CAST(0)  // zero terminator
                }
            };
            me->serial.close();
            status_ = QM_TRAN(&tatbl_);
            break;
        }
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    return status_;
}
//${components::Pelican::SM::final} ..........................................
QP::QMState const Pelican::final_s = {
    static_cast<QP::QMState const *>(0), // superstate (top)
    Q_STATE_CAST(&final),
    Q_ACTION_CAST(&final_e),
    Q_ACTION_CAST(0), // no exit action
    Q_ACTION_CAST(0)  // no intitial tran.
};
// ${components::Pelican::SM::final}
QP::QState Pelican::final_e(Pelican * const me) {
    BSP_terminate(0);
    (void)me; // avoid compiler warning in case 'me' is not used
    return QM_ENTRY(&final_s);
}
// ${components::Pelican::SM::final}
QP::QState Pelican::final(Pelican * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        default: {
            status_ = QM_SUPER();
            break;
        }
    }
    (void)me; /* avoid compiler warning in case 'me' is not used */
    return status_;
}

} // namespace PELICAN
